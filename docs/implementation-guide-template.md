# {プロジェクト名} 実装ガイド

## 概要

このプロジェクトの目的と、実装ガイドの役割を説明します。

**プロジェクトの目的**: {プロジェクトの目的を1〜2文で}

**このガイドの役割**: 実装者が迷わず、品質を担保しながら開発を進めるための指針を提供します。

---

## アーキテクチャ

### 全体構成

```
project/
├── src/
│   ├── components/  # UIコンポーネント
│   ├── hooks/       # カスタムフック
│   ├── lib/         # ユーティリティ
│   └── types/       # 型定義
├── tests/           # テスト
└── docs/            # ドキュメント
```

### 技術スタック

- **フレームワーク**: {React/Vue/Next.js等}
- **言語**: {TypeScript/JavaScript等}
- **テスト**: {Jest/Vitest等}
- **スタイル**: {Tailwind/CSS Modules等}
- **状態管理**: {Redux/Zustand/Context等}
- **API通信**: {Axios/Fetch/tRPC等}

---

## 実装原則

### 1. コンポーネントの独立性

各コンポーネントは独立してテスト可能であること。

**理由**: デグレードを防ぎ、保守性を高めるため。

**実装例**:
```typescript
// ✅ Good: 独立したコンポーネント
export function Button({ onClick, label }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>;
}

// ❌ Bad: グローバル状態に依存
export function Button() {
  const { onClick, label } = useGlobalState(); // グローバル依存
  return <button onClick={onClick}>{label}</button>;
}
```

### 2. 型安全性

TypeScriptの型チェックを最大限活用すること。

**理由**: 実行時エラーを防ぎ、リファクタリングを安全にするため。

**実装例**:
```typescript
// ✅ Good: 型定義が明確
interface User {
  id: string;
  name: string;
  email: string;
}

function getUser(id: string): Promise<User> {
  // ...
}

// ❌ Bad: any型を使用
function getUser(id: any): Promise<any> {
  // ...
}
```

### 3. テストカバレッジ

重要なロジックには必ずユニットテストを書くこと。

**理由**: リグレッションを防ぎ、リファクタリングを安全にするため。

**実装例**:
```typescript
// ✅ Good: テストがある
describe('calculateTotal', () => {
  it('should calculate total correctly', () => {
    expect(calculateTotal([1, 2, 3])).toBe(6);
  });
});

// ❌ Bad: テストがない
function calculateTotal(numbers: number[]): number {
  return numbers.reduce((a, b) => a + b, 0);
}
// テストなし
```

---

## PR分割戦略

### 大きな機能の分割例

**機能: ユーザー認証システム**

```
├── PR-1: ログインボタンとモーダルUI
│   ├── 実装内容: ボタンコンポーネント、モーダルコンポーネント
│   ├── テスト: UIコンポーネントのユニットテスト
│   └── 影響範囲: components/auth/
├── PR-2: ログインAPI呼び出し追加
│   ├── 実装内容: API呼び出しロジック、エラーハンドリング
│   ├── テスト: API呼び出しのモックテスト
│   └── 影響範囲: lib/api/, hooks/use-auth.ts
├── PR-3: ログイン成功時の画面遷移
│   ├── 実装内容: 成功画面、リダイレクト処理
│   ├── テスト: 画面遷移のユニットテスト
│   └── 影響範囲: components/auth/, lib/navigation.ts
├── PR-4: エラーハンドリング
│   ├── 実装内容: エラー画面、リトライ処理
│   ├── テスト: エラーケースのユニットテスト
│   └── 影響範囲: components/auth/, hooks/use-auth.ts
└── PR-5: 全体統合とE2Eテスト
    ├── 実装内容: E2Eテスト、最終調整
    ├── テスト: E2Eテスト
    └── 影響範囲: tests/e2e/
```

### PR分割の原則

1. **1PR = 1つの明確な目的**
2. **PRは独立してテスト可能**
3. **PRは独立してロールバック可能**
4. **PRのサイズは小さく（変更ファイル数: 3〜10ファイル程度）**

---

## NG集

詳細は `docs/ng-list.md` を参照。

**主なNG項目**:
- {NG項目1}
- {NG項目2}
- {NG項目3}

---

## レビューチェックリスト

詳細は `docs/review-checklist-template.md` を参照。

**主なチェック項目**:
- [ ] NG集に違反していない
- [ ] TypeScriptの型エラーがない
- [ ] ユニットテストが追加されている
- [ ] 既存テストが全てパスする
- [ ] 既存機能が壊れていない

---

## トラブルシューティング

### よくある問題と解決策

#### 問題1: TypeScriptの型エラーが解決できない

**原因**: 型定義が不完全、または型推論が失敗している

**解決策**:
1. 型定義を明示的に書く
2. `as` キャストを使う（最終手段）
3. ChatGPTに相談する

#### 問題2: テストが通らない

**原因**: モックが不完全、または非同期処理の待機が不足

**解決策**:
1. モックを完全に設定する
2. `await` を使って非同期処理を待つ
3. `act()` を使ってReactの更新を待つ

#### 問題3: 既存機能が壊れた（デグレード）

**原因**: 影響範囲の見積もりが不足、またはテストが不足

**解決策**:
1. `git diff` で変更箇所を確認
2. 影響範囲を特定し、テストを追加
3. ロールバックして再実装

---

## 開発フロー

### 1. 実装前

1. **実装ガイドを読む**: このファイルとNG集を確認
2. **ChatGPTに相談**: 実装方針を相談
3. **PRを作成**: GitHub上でPRを作成（Draft状態）

### 2. 実装中

1. **小さく実装**: 1つのPRで1つの目的
2. **テストを書く**: 実装と同時にテストを書く
3. **型チェック**: `npm run check` で型エラーを確認

### 3. 実装後

1. **レビューチェックリスト**: `docs/review-checklist-template.md` を使ってセルフレビュー
2. **ChatGPTにレビュー依頼**: 実装ガイドとNG集を添付してレビュー依頼
3. **PRをReady for Review**: レビュー準備完了

### 4. レビュー後

1. **修正**: レビューコメントに対応
2. **再レビュー**: 修正内容を再度レビュー
3. **マージ**: レビュー承認後、マージ

---

## ChatGPTへの相談テンプレート

実装前に、以下のテンプレートを使ってChatGPTに相談します。

```
以下のPRを実装しようと思います。
実装ガイドとNG集に違反していないか、
デグレードリスクがないか確認してください。

## 実装ガイド

（このファイルの内容をコピペ）

## NG集

（docs/ng-list.mdの内容をコピペ）

## 実装予定のコード差分

（git diffの内容をコピペ、またはファイルを添付）

## 質問

1. この実装方針は妥当ですか？
2. デグレードリスクはありますか？
3. より良い実装方法はありますか？
```

---

## まとめ

このガイドを使うことで、以下のメリットがあります。

1. **品質向上**: デグレードや設計ミスを防ぐ
2. **開発速度向上**: レビューがスムーズになり、手戻りが減る
3. **チーム協働**: ドキュメントが残り、知識が共有される
4. **安心感**: 「どこか直したら他が壊れる」問題が解消される

**実装前に必ずこのガイドを読み、ChatGPTに相談してください！**
