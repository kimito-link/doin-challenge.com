# データ構造から考える開発原則

**最終更新**: 2026-02-02  
**対象者**: 開発者全員

実務でコードを書いていると、「この処理、どこから手をつければいいんだろう」と立ち止まる瞬間に何度も出会います。少し仕様が変わっただけで影響範囲が読めなくなる。1つ修正すると、思わぬ別の場所が壊れる。自分では丁寧に書いているつもりなのに、どんどん扱いづらくなっていく。

こうした"壊れやすいコード"には、共通点があります。それは、**データ構造が曖昧なまま実装に入っていること**です。

優秀なエンジニアほど、コードを書く前に「まず扱うデータをどう設計するか」に時間を使います。これはセンスではなく、壊れにくいシステムを作るうえでの再現性のあるプロセスです。

---

## なぜデータから考えると壊れにくくなるのか

コードが壊れる原因は「処理が複雑だから」ではありません。多くの場合、**扱うデータが曖昧なまま実装が進んでしまっている**ことが本質的な原因です。

### 処理から考え始めると起きる問題

処理から考え始めると、次のような問題が起きやすくなります：

- **想定外の値が混ざる**
- **null / undefined が途中で暴れる**
- **状態管理が if 文で散らばる**

これは本来、コードを書く前に決めておくべき「前提条件」がコードの外に残ったままになっている状態です。この"前提の漏れ"が、仕様変更のたびに壊れる構造を生みます。

### データを先に設計するメリット

一方でデータを先に設計しておくと、以下が明確になり、実装に一貫した「軸」が生まれます：

- **何が入力なのか**
- **何が正常な状態なのか**
- **何が起きると不整合になるのか**

---

## 何をデータ構造として扱うべきか

「データから考えろ」と言われても、実務では"何をデータとみなすのか"が分からず迷いがちです。ここからは、データ構造として扱うべきポイントを4つの視点で整理します。

### 1. "情報"ではなく"状態"をデータとみなす

多くの人は「データ＝文字や数値」と捉えますが、実務で重要なのは**状態**です。

たとえば：

- ログイン前 / ログイン後
- 未読 / 既読
- 有効 / 無効
- 下書き / 公開

これらは UI のラベルではなく、**アプリケーションが保証すべき前提そのもの**です。状態が曖昧なまま実装すると、if 文が散らばり、仕様変更のたびに壊れます。

### 2. "値"だけでなく"関係"もデータ構造に含める

データ設計で見落とされがちなのは**関係性**です。

- ユーザーと組織
- 記事とコメント
- 予約枠と担当者
- 商品と在庫

関係性が曖昧なまま実装すると、「このデータ、どれと紐づいてるんだっけ？」という混乱が必ず発生します。関係は「おまけ」ではありません。**データ構造そのものの中心**です。

### 3. "仕様に書かれていない前提"をデータ化する

実務には、仕様書では見落とされている重要な前提が必ず存在します。

例えば：

- ユーザーは1つの組織にしか所属できない
- 予約は「担当者 × サービス × 日時」で一意になる
- メッセージの編集履歴は削除後も保持する

こうした暗黙にされているかもしれない前提をデータに落とし込まないと、機能がその前提に依存していたときに壊れるという事故が起きます。

優秀なエンジニアほど、**仕様に書かれていない前提を発掘してデータとして扱う**という工程を怠りません。

### 4. 最初は「自然言語で書ける」ことが大事

最初からER図やクラス図を書く必要はありません。まずやるべきなのは、**扱う状態や前提を自然言語で説明できるようにすること**です。

たとえば：

- ユーザーは複数組織に所属できるが、デフォルト組織は1つ
- 予約は日時・担当者・サービスの3つが揃って成立する
- メッセージ編集は可能だが、履歴は別レコードで保持する

自然言語で曖昧なら、コードではもっと曖昧になります。

---

## 実務でデータ構造を決めるときのステップ

ここからは、「実際どうやってデータ構造を決めればいいのか？」という実務のプロセスを紹介します。

### Step 1: 自然言語で「状態」「関係」「前提」を列挙する

まずはコードから離れて、自然言語で現在の仕様を洗い出すところから始めます。

- 予約は日時 × 担当者 × サービスで構成される
- ユーザーは複数組織に所属できるがデフォルト組織は1つ
- メッセージ編集は可能だが履歴は残す

曖昧な表現でも構いません。最初は「**全体像を漏れなく書き出す**」ことが大事です。

### Step 2: 同じ概念をまとめ、不要な状態を削る

洗い出した状態や関係を見直し、以下を判断して整理します：

- **本当にアプリが管理すべき状態はどれか**
- **UIの名前ではなく構造として必要な状態はどれか**

状態は多ければ多いほど壊れやすくなるため、**削る工程こそ設計の核心**です。

### Step 3: 変化する状態と変化しない状態を分ける

「どの値が変化し、どの値が不変か」を明確にします。

**例：**

- 予約の「作成日時」は不変
- 予約の「ステータス」は可変
- ユーザーIDは不変
- メールアドレスは可変

この境界線を引くだけで、更新ロジックのバグが激減します。

### Step 4: 状態遷移（ステートマシン）を書く

状態が整理できたら、**どの状態からどの状態に遷移できるか**を明文化します。

**例（予約）：**

```
draft → reserved → completed
draft → canceled
reserved → canceled
```

これにより、以下がすぐに可視化されます：

- 到達しない状態
- 不正遷移
- 不整合の原因

### Step 5: データ構造として定義する（型・スキーマ化）

ここまで整理した情報を**型・スキーマ・ER図**に落とし込みます。

- TypeScriptの型
- Prisma schema
- Rustのstruct + enum
- Swiftのstruct/enum
- DBのテーブル定義

状態・前提・関係が整理されているので、ここから先の実装は驚くほどスムーズです。

---

## まとめ：データ構造を決める作業は、実装より重要

データ構造の設計は、実装の"前作業"ではありません。**実装を壊れにくくするための中心工程**です。

### 重要なポイント

- **曖昧なまま書き始めるほど壊れやすくなる**
- **データが明確なら処理は自然とシンプルになる**
- **状態・関係・前提が揃えば、仕様変更に強くなる**

優秀なエンジニアがデータ構造を先に決めるのは、センスではありません。**後の開発すべてを安定させる"最もコスパの良い投資"**だからです。

---

## 採用による期待される成果

**注意**: 以下の数値は一般的なプロジェクトの目安です。チーム規模・既存負債・テスト整備状況により上下します。

### 短期的な効果（1-2週間）

- **バグ発生率の減少**: 30-50%の減少が期待できます
  - 想定外の値やnull/undefinedエラーの減少
  - 状態管理の不整合によるバグの減少
- **開発速度の向上**: 実装前に設計することで、後戻りが減り、全体で20-30%の時間短縮
- **コードレビューの効率化**: データ構造が明確なため、レビュー時間が30-40%短縮

### 中期的な効果（1-3ヶ月）

- **リファクタリングコストの削減**: 50-70%の削減
  - 仕様変更時の影響範囲が明確
  - データ構造が明確なため、安全にリファクタリング可能
- **新機能追加の速度向上**: 40-60%の速度向上
  - 既存のデータ構造を拡張する形で実装可能
  - 影響範囲が明確なため、テストが効率的
- **技術的負債の蓄積防止**: データ構造が明確なため、負債が蓄積しにくい

### 長期的な効果（3ヶ月以上）

- **保守性の向上**: メンテナンスコストが50-70%削減
  - コードの理解が容易
  - バグの原因特定が迅速
- **チーム開発の効率化**: オンボーディング時間が30-50%短縮
  - データ構造が明確なため、新メンバーが理解しやすい
- **品質の向上**: 本番環境での重大なバグが60-80%減少

### 投資対効果（ROI）

**時間投資**: 実装前のデータ構造設計に、実装時間の10-20%を投資

**リターン**:
- バグ修正時間: 50-70%削減
- リファクタリング時間: 50-70%削減
- 新機能追加時間: 40-60%削減
- コードレビュー時間: 30-40%削減

**総合的な効果**: 開発全体で**30-50%の時間削減**が期待できます。

### 注意点

- **最初の1-2週間は時間がかかる**: データ構造を設計する時間が必要
- **チーム全体での理解が必要**: 個人だけでなく、チーム全体でこの原則を理解する必要がある
- **継続的な改善**: データ構造は一度決めたら終わりではなく、仕様変更に応じて見直す必要がある

---

## 関連ドキュメント

- [docs/LOCAL_DEVELOPMENT_WORKFLOW.md](./LOCAL_DEVELOPMENT_WORKFLOW.md) - ローカル開発ワークフロー
- [docs/ARCHITECTURE.md](./ARCHITECTURE.md) - アーキテクチャ設計
- [DESIGN_PRINCIPLES.md](../DESIGN_PRINCIPLES.md) - デザイン原則

---

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|---------|
| 2026-02-02 | v1.0 | 初版作成 - データ構造から考える開発原則の確立 |
