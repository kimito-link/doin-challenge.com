# データ設計テンプレート（Data Design Template）

このテンプレートは、**データ駆動設計（Data-Driven Design）**のプロセスを実践するためのガイドです。実装前にデータ構造を整理することで、仕様変更に強く、壊れにくいシステムを構築できます。

---

## なぜデータ構造を先に決めるのか？

コードが壊れる原因は「処理が複雑だから」ではありません。多くの場合、**扱うデータが曖昧なまま実装が進んでしまっている**ことが本質的な原因です。

### 処理から考え始めると起きる問題
- 想定外の値が混ざる
- `null` / `undefined` が途中で暴れる
- 状態管理が `if` 文で散らばる

### データ構造を先に決めると得られるメリット
- 仕様変更に強くなる
- バグが減る
- コードがシンプルになる
- チーム内の認識が揃う

---

## データ設計の5ステップ

### Step1: 自然言語で「状態」「関係」「前提」を列挙する

まず、仕様書や要件定義から、以下の3つを自然言語で書き出します。

#### 状態（States）
「このシステムが扱う状態は何か？」を列挙します。状態は「UIのラベル」ではなく、「アプリケーションが保証すべき前提」として定義します。

**例（ECサイトの注文）**:
- 注文: 未確定 / 確定済み / 発送済み / 配送中 / 配達完了 / キャンセル済み
- 在庫: 在庫あり / 在庫なし / 入荷待ち
- ユーザー: 未ログイン / ログイン済み / 退会済み

#### 関係（Relationships）
「データ間の関係性は何か？」を列挙します。関係性が曖昧なまま実装すると、「このデータ、どれと紐づいてるんだっけ？」という混乱が発生します。

**例（ECサイトの注文）**:
- ユーザー 1:N 注文（ユーザーは複数の注文を持つ）
- 注文 1:N 注文明細（注文は複数の商品を含む）
- 商品 1:N 注文明細（商品は複数の注文に含まれる）
- 注文 1:1 配送先（注文は1つの配送先を持つ）

#### 前提（Assumptions）
「仕様書に書かれていないが、システムが依存している前提条件は何か？」を列挙します。これらを明文化することで、仕様変更時の影響範囲が明確になります。

**例（ECサイトの注文）**:
- ユーザーは複数の配送先を登録できる
- 注文確定後は、商品の追加・削除ができない
- 在庫がない商品は注文できない
- キャンセル済みの注文は、再度確定できない
- 配送先は、注文確定後も変更できる（発送前のみ）

---

### Step2: 同じ概念をまとめ、不要な状態を削る

Step1で列挙した状態の中から、以下を整理します：
- **同じ概念を表す状態をまとめる**（例: 「未確定」と「下書き」は同じ）
- **不要な状態を削る**（例: 「配送中」と「配達完了」は、配送業者のシステムで管理すべき）

**例（ECサイトの注文）**:
- 削除: 「未確定」と「下書き」は同じ → 「未確定」に統一
- 削除: 「配送中」と「配達完了」は配送業者のシステムで管理 → 「発送済み」のみ残す
- 残す: 「確定済み」「発送済み」「キャンセル済み」

---

### Step3: 変化する状態と変化しない状態を分ける

どの値が変化し、どの値が不変かを明確にします。この境界線を引くだけで、更新ロジックのバグが激減します。

**例（ECサイトの注文）**:

#### 不変（Immutable）
- 注文ID
- 注文日時
- ユーザーID
- 商品ID

#### 可変（Mutable）
- 注文ステータス（未確定 → 確定済み → 発送済み）
- 配送先住所（発送前のみ変更可能）
- 在庫数（注文のたびに減少）

---

### Step4: 状態遷移（ステートマシン）を書く

状態が整理できたら、**どの状態からどの状態に遷移できるか**を明文化します。

**例（ECサイトの注文）**:
```
未確定
  ↓ ユーザーが注文確定ボタンをクリック
確定済み
  ↓ 管理者が発送処理を実行
発送済み

未確定 → キャンセル済み（ユーザーがキャンセル）
確定済み → キャンセル済み（ユーザーがキャンセル、発送前のみ）
```

**遷移不可**:
- 発送済み → 確定済み（発送後は戻せない）
- キャンセル済み → 確定済み（キャンセル後は再確定できない）

これにより、以下が可視化されます：
- 到達しない状態
- 不正遷移
- 不整合の原因

---

### Step5: データ構造として定義する（型・スキーマ化）

ここまで整理した情報を、**型・スキーマ・ER図**に落とし込みます。

**例（TypeScript）**:
```typescript
// 注文ステータス
type OrderStatus = "pending" | "confirmed" | "shipped" | "canceled";

// 注文
type Order = {
  id: number;              // 不変
  userId: number;          // 不変
  status: OrderStatus;     // 可変
  shippingAddress: string; // 可変（発送前のみ）
  createdAt: Date;         // 不変
  updatedAt: Date;         // 可変
};

// 注文明細
type OrderItem = {
  id: number;              // 不変
  orderId: number;         // 不変
  productId: number;       // 不変
  quantity: number;        // 不変（注文確定後は変更不可）
  price: number;           // 不変（注文時の価格を記録）
};
```

**例（Prisma Schema）**:
```prisma
model Order {
  id              Int         @id @default(autoincrement())
  userId          Int
  status          OrderStatus @default(pending)
  shippingAddress String
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  user            User        @relation(fields: [userId], references: [id])
  items           OrderItem[]
}

model OrderItem {
  id        Int   @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int
  price     Int
  order     Order   @relation(fields: [orderId], references: [id])
  product   Product @relation(fields: [productId], references: [id])
}

enum OrderStatus {
  pending
  confirmed
  shipped
  canceled
}
```

状態・前提・関係が整理されているので、**ここから先の実装は驚くほどスムーズ**です。

---

## テンプレート（コピー用）

以下のテンプレートをコピーして、プロジェクトの`docs/DESIGN.md`や`docs/REQUIREMENTS.md`に貼り付けてください。

```markdown
## データ設計（Data-Driven Design）

### 1. 状態（States）

#### [エンティティ名]
- **[状態1]**: [説明]
- **[状態2]**: [説明]
- **[状態3]**: [説明]

**補足**: [追加情報]

---

### 2. 関係（Relationships）

#### 主要な関係
\`\`\`
[エンティティA] (1) ←→ (N) [エンティティB]
  ↓
  [説明]

[エンティティB] (1) ←→ (N) [エンティティC]
  ↓
  [説明]
\`\`\`

#### ER図（簡易版）
\`\`\`
┌─────────┐       ┌─────────────┐       ┌────────────────┐
│ [A]     │1────N │ [B]         │1────N │ [C]            │
└─────────┘       └─────────────┘       └────────────────┘
\`\`\`

---

### 3. 前提（Assumptions）

#### [カテゴリ名]
- [前提1]
- [前提2]
- [前提3]

---

### 4. 変化する状態と変化しない状態

#### 不変（Immutable）
- `[エンティティ].[フィールド]`
- `[エンティティ].[フィールド]`

#### 可変（Mutable）
- `[エンティティ].[フィールド]`
- `[エンティティ].[フィールド]`

---

### 5. 状態遷移図（State Transition Diagram）

#### [エンティティ名]
\`\`\`
[状態1]
  ↓ [遷移条件]
[状態2]
  ↓ [遷移条件]
[状態3]

[状態1] → [状態4]（[遷移条件]）
\`\`\`

**遷移条件**:
- `[状態1]` → `[状態2]`: [説明]
- `[状態2]` → `[状態3]`: [説明]

**遷移不可**:
- `[状態3]` → `[状態1]`: [理由]

**補足**:
- [追加情報]

---

### 6. データ構造の定義（Schema）

#### [エンティティ名]
\`\`\`typescript
{
  id: number;              // [説明]
  [フィールド]: [型];      // [説明]
  createdAt: Date;         // [説明]
  updatedAt: Date;         // [説明]
}
\`\`\`

---

### 7. データ設計の原則

#### 原則1: データ構造を先に決める
実装前に、扱うデータの「状態」「関係」「前提」を明文化します。

#### 原則2: 状態は最小限に
状態が多ければ多いほど、システムは壊れやすくなります。

#### 原則3: 関係性を明確にする
データ間の関係性を曖昧にしたまま実装すると、混乱が発生します。

#### 原則4: 暗黙の前提を明文化する
仕様書に書かれていない前提条件を洗い出し、明文化します。

#### 原則5: 変化する状態と変化しない状態を分ける
どの値が変化し、どの値が不変かを明確にします。

#### 原則6: 状態遷移を可視化する
状態がどのように遷移するかを明文化します。

---

### 8. データ設計の更新履歴

#### [日付]: [変更内容]
- [詳細]
```

---

## 実践例

このテンプレートを使った実践例は、以下のプロジェクトを参照してください：

- **動員ちゃれんじ（doin-challenge）**: `docs/DESIGN.md`、`docs/REQUIREMENTS.md`

---

## よくある質問

### Q1: データ設計にどれくらい時間をかけるべき？
**A**: プロジェクトの規模によりますが、**実装時間の10〜20%**を目安にしてください。例えば、実装に1週間かかる場合、データ設計に1〜2日かけるのが適切です。

### Q2: データ設計を後から変更してもいい？
**A**: はい、変更可能です。ただし、**変更履歴を記録**し、影響範囲を明確にしてください。データ設計を明文化しておくことで、変更時の影響範囲が把握しやすくなります。

### Q3: すでに実装が進んでいるプロジェクトにも適用できる？
**A**: はい、適用可能です。まず、既存のデータ構造を分析・整理し、このテンプレートに沿ってドキュメント化してください。その後、不整合や曖昧な部分を修正していきます。

### Q4: チーム開発でどう活用する？
**A**: データ設計を**レビューの対象**にしてください。実装前にデータ設計をレビューすることで、チーム内の認識が揃い、後戻りが減ります。

### Q5: データ設計とER図の違いは？
**A**: ER図は「関係性」を可視化するツールですが、データ設計は「状態」「前提」「変化する状態と変化しない状態」「状態遷移」も含みます。ER図はデータ設計の一部です。

---

## 参考資料

### データ駆動設計について
- [優秀なエンジニアがデータ構造を先に決める理由](https://zenn.dev/articles/data-first-design)
- [データ設計の原則](https://zenn.dev/articles/data-design-principles)
- [ステートマシンパターン](https://zenn.dev/articles/state-machine-pattern)

### 関連ドキュメント
- `docs/DESIGN.md`: プロジェクト固有のデータ設計
- `docs/REQUIREMENTS.md`: 要件定義（状態遷移図を含む）
- `docs/ARCHITECTURE.md`: アーキテクチャ設計

---

## まとめ

データ構造の設計は、実装の"前作業"ではありません。**実装を壊れにくくするための中心工程**です。

- 曖昧なまま書き始めるほど壊れやすくなる
- データが明確なら処理は自然とシンプルになる
- 状態・関係・前提が揃えば、仕様変更に強くなる

優秀なエンジニアがデータ構造を先に決めるのは、センスではありません。**後の開発すべてを安定させる"最もコスパの良い投資"**だからです。

---

## ライセンス

このテンプレートは、MITライセンスで公開されています。自由に使用・改変・再配布してください。

---

## 更新履歴

- **2026-02-02**: 初版作成
